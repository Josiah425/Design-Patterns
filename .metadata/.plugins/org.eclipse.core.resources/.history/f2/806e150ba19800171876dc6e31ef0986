
public class MyArrayListTest {
	
	public void testMe(MyArrayList myArrayList, Results results){
		results.storeNewResults("The sum of all the values in the array list is: " + myArrayList.sum());
		if(capacityIncrease(myArrayList)) results.storeNewResults("test capacityIncrease passed");
		else results.storeNewResults("test capacityIncrease failed, throws illegal index out of bound exception");
		if(indexOfNotFound(myArrayList)) results.storeNewResults("test indexOfNotFound passed");
		else results.storeNewResults("tes indexOfNotFound failed, returns a location of a value that shouldn't be in array list");
		if(insertOutOfRange(myArrayList))results.storeNewResults("test insertOutOfRange passed");
		else results.storeNewResults("test insertOutOfRange failed, did not throw illegal argument exception");
		if(removeElement(myArrayList)) results.storeNewResults("test removeElement passed");
		else results.storeNewResults("test removeElement failed, array list before and after manipulation were not the same");
		if(sizeIncrement(myArrayList)) results.storeNewResults("test sizeIncrement passed");
		else results.storeNewResults("test sizeIncrement failed, size didn't increment correctly");
		if(insertUniqueValue(myArrayList)) results.storeNewResults("test insertUniqueValue passed");
		else results.storeNewResults("test insertUniqueValue failed, inserted value did not get placed correctly");
		
	}
	
	public boolean capacityIncrease(MyArrayList myArrayList){
		//If it's already bigger than 50, then we know we increased the capacity of the array list at one point
		if(myArrayList.size() > 50) return true;
		//Add 51 elements to force a change in array list capacity, since we know initial is 50
		for(int i = 0; i < 51; i++){
			try{
				myArrayList.insertSorted(i);
			}
			catch(ArrayIndexOutOfBoundsException e){
				System.err.println("Failed to increase capacity of array");
				return false;
			}
		}
		return true;
	}
	
	public boolean indexOfNotFound(MyArrayList myArrayList){
		myArrayList.removeValue(5000);
		if(myArrayList.indexOf(5000) != -1) return false;
		return true;
	}
	
	public boolean indexOfFoundValue(MyArrayList myArrayList){
		myArrayList.removeValue(0);
		myArrayList.removeValue(1);
		myArrayList.removeValue(2);
		myArrayList.insertSorted(1);
		myArrayList.insertSorted(0);
		myArrayList.insertSorted(1);
		myArrayList.insertSorted(2);
		if(myArrayList.indexOf(0) == 0 && myArrayList.indexOf(1) == 1 && myArrayList.indexOf(2) == 3) return true;
		return false;
	}
	
	public boolean insertOutOfRange(MyArrayList myArrayList){
		try{
			myArrayList.insertSorted(10001);
		}
		catch(IllegalArgumentException e){
			System.err.println("Caught expected exception for illegal value");
			return true;
		}
		return false;
	}
	
	public boolean removeElement(MyArrayList myArrayList){
		myArrayList.removeValue(5000);
		int val = 0;
		boolean valFound = false;
		MyArrayList temp = new MyArrayList();
		int[] arr = new int[10000];
		int prev = 0;
		int prevVal = 0;
		for(int i = 0; i < 10000; i++){
			arr[i] = myArrayList.indexOf(i);
		}
		for(int i = 0; i < 10000; i++){
			if(myArrayList.indexOf(i) == -1 && !valFound){
				val = i;
				valFound = true;
				break;
			}
			if(arr[i] != -1){
				if(i != 9999) for(int j = 0; j < arr[i]-prev; j++) temp.insertSorted(prevVal);
				else for(int j = 0; j < myArrayList.size()-arr[i]; j++) temp.insertSorted(prevVal);
				prev = arr[i];
				prevVal = i;
			}
		}
		for(int j = 0; j < myArrayList.size()-prev; j++) temp.insertSorted(prevVal);
		myArrayList.insertSorted(val);
		myArrayList.insertSorted(val);
		myArrayList.insertSorted(val);
		myArrayList.removeValue(val);
		if(myArrayList.equals(temp)){
			return true;
		}
		return false;
	}
	
	public boolean sizeIncrement(MyArrayList myArrayList){
		myArrayList.removeValue(5000);
		int val = 0;
		boolean valFound = false;
		MyArrayList temp = new MyArrayList();
		int[] arr = new int[10000];
		int prev = 0;
		int prevVal = 0;
		for(int i = 0; i < 10000; i++){
			arr[i] = myArrayList.indexOf(i);
		}
		for(int i = 0; i <= 10000; i++){
			if(myArrayList.indexOf(i) == -1 && !valFound){
				val = i;
				valFound = true;
				break;
			}
			/*
			 * Creating the original myArrayList before it's 
			 * manipulated in a temp array list to compare
			 */
			if(arr[i] != -1){
				if(i != 9999) for(int j = 0; j < arr[i]-prev; j++) temp.insertSorted(prevVal);
				else for(int j = 0; j < myArrayList.size()-arr[i]; j++) temp.insertSorted(prevVal);
				prev = arr[i];
				prevVal = i;
			}
		}
		for(int j = 0; j < myArrayList.size()-prev; j++) temp.insertSorted(prevVal);
		myArrayList.insertSorted(val);
		myArrayList.insertSorted(val);
		myArrayList.insertSorted(val);
		if(myArrayList.size() == temp.size()+3){
			return true;
		}
		return false;
	}
	
	public boolean insertUniqueValue(MyArrayList myArrayList){
		myArrayList.removeValue(5000);
		int val = 0;
		boolean valFound = false;
		boolean nextFound = false;
		MyArrayList temp = new MyArrayList();
		int[] arr = new int[10000];
		int prev = 0;
		int prevVal = 0;
		int next = 0;
		/*
		 * Getting the index values of elements
		 * so I can add in the elements into temp array list
		 */
		for(int i = 0; i < 10000; i++){
			arr[i] = myArrayList.indexOf(i);
		}
		for(int i = 0; i < 10000; i++){
			/*
			 * Finding the first val that doesn't appear in the array list
			 */
			if(myArrayList.indexOf(i) == -1 && !valFound){
				val = i;
				valFound = true;
				break;
			}
			/*
			 * Finding the next val that doesn't appear in array list
			 */
			if(valFound && !nextFound && myArrayList.indexOf(i) != -1){
				next = i;
				nextFound = true;
			}
			/*
			 * Creating the original myArrayList before it's 
			 * manipulated in a temp array list to compare
			 */
			if(arr[i] != -1){
				if(i != 9999) for(int j = 0; j < arr[i]-prev; j++) temp.insertSorted(prevVal);
				else for(int j = 0; j < myArrayList.size()-arr[i]; j++) temp.insertSorted(prevVal);
				prev = arr[i];
				prevVal = i;
			}
		}
		/*
		 * Store the last instance of a value
		 */
		for(int j = 0; j < myArrayList.size()-prev; j++) temp.insertSorted(prevVal);
		myArrayList.insertSorted(val);
		/*
		 * This means there is no next value, therefore it should
		 * be placed at the end of the arrayList
		 */
		if(next == 0 && myArrayList.indexOf(val) == temp.size()) return true;
		/*
		* This means that it wasn't inserted in the correct spot, 
		* otherwise the inserted values index would be the same
		* as the next value of the original array list
		*/
		else if(myArrayList.indexOf(val) != temp.indexOf(next)) return false;
		return true;
	}
}
